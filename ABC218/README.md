# REVIEW
### A
- 一瞬
- YesNo(s[n-1] == 'o')

### B
- 一瞬
- REP(i,26) cout << (char)(p + 'a' - 1);

### C(WA)
- 愚直な実装では無理なのでそれを改良しようと試みたがﾑﾘ
- なるほどn x n行列でとるのではなく辺の座標のlistをいじればよかった

### D
1. 2頂点全探索してy座標が同じ頂点2つu,v(u.x<v.x)を選ぶ
2. u.xにv.xまでの距離を紐づけたペアをkeyとして，それを数える(map : m)
3. (同じ頂点は入力されないので) 各keyについてm[key]が2以上だったら長方形ができる
4. m[key] = nとすると，n個のペアのなかでy座標が違うものの組み合わせとなるため，_nC_2個の長方形ができる
5.数える

### E(WA)
- 問題文すら読んでない
= 最小全域木構築のコスト部分をややこしくした感じ
