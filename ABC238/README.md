# REVIEW
### A
- 2^n = n^2 -> n = 2, 4なので 2 ~ 4に含まれるか判定するだけ

### B
- シミュレートしてsortして一番広いところ探す

### C
- すごいバグ取り除くのに時間かかった
- (桁数-1)桁までは REP(i, 桁数) 1 ~ 9 * 10^(i-1)の総和 を考えればよくて，桁数桁は1からn-10^(桁数-1)の総和を考える
- modint使う時のタイミングと2で割る時にそれが偶数か判定するのに手間取った

### D
- a = x & y, s = x + y
- 具体例として a = 5, s = 20とすると，a(2) = 0101, s(2) = 1010
- a = x & yなので，x = A1B1, y = C1D1 (A&C=0 && B&D=0)
- s = A1B1 + C1D1であることを考えると，s - 2 * a = A0B0 + C0D0 = (A+C)0(B+D)0であることがわかり，それを満たすA,B,C,Dが存在するかを考える
- s - 2 * a = 20 - 2 * 5 = 10 = 1010なので，たとえば(A,B,C,D) = (1,1,0,0)で成り立つ
  - これが成り立たないのは，s - 2*a < 0 もしくは s - 2 * a & a != 0であるとき

- a = 5, s = 21とする
- a(2) = 0101, s(2) = 1011
- x = A1B1, y = C1D1 (A&C=0 && B&D=0)
- s - 2 * a = 11 = 1011(2) = (A+C)0(B+D)0
- 下位1bitが1であり，表現できないためNoを返す
  - (s - 2 * a) & a = 0001 neq 0
